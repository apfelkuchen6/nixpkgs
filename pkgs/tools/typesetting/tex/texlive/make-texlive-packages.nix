{ lib, tlpdb, tlpdbxz, bin, useFixedHashes, fixedHashes, urlPrefixes, runCommand, fetchurl
, bash, perl, python3, ruby, jdk, tk, ...}@args:
let

  attrFun = self: with self; {

  tlpdbVersion = tlpdb."00texlive.config";

  # most format -> engine links are generated by texlinks according to fmtutil.cnf at combine time
  # so we remove them from binfiles, and add back the ones texlinks purposefully ignore (e.g. mptopdf)
  removeFormatLinks = lib.mapAttrs (_: attrs:
    if (attrs ? formats && attrs ? binfiles)
    then let formatLinks = lib.catAttrs "name" (lib.filter (f: f.name != f.engine) attrs.formats);
              binNoFormats = lib.subtractLists formatLinks attrs.binfiles;
          in if binNoFormats != [] then attrs // { binfiles = binNoFormats; } else removeAttrs attrs [ "binfiles" ]
    else attrs);

  orig = removeFormatLinks (removeAttrs tlpdb [ "00texlive.config" ]);

  overridden = orig // {
    # overrides of texlive.tlpdb

    # only *.po for tlmgr
    texlive-msg-translations = builtins.removeAttrs orig.texlive-msg-translations [ "hasTlpkg" ];

    # TODO we do not build binaries for the following packages (yet!)
    biber-ms = removeAttrs orig.biber-ms [ "binfiles" ];
    xpdfopen = removeAttrs orig.xpdfopen [ "binfiles" ];

    # packages with nonstandard script arrangements

    cluttex = orig.cluttex // {
      binaliases = {
        cllualatex = "cluttex";
        clxelatex = "cluttex";
      };
    };

    context = orig.context // {
      scriptsFolder = "context/stubs/unix";
    };

    cyrillic-bin = orig.cyrillic-bin // {
      scriptsFolder = "texlive-extra";
    };

    epstopdf = orig.epstopdf // {
      binaliases = {
        repstopdf = "epstopdf";
      };
    };

    fontinst = orig.fontinst // {
      scriptsFolder = "texlive-extra";
    };

    mptopdf = orig.mptopdf // {
      scriptsFolder = "context/perl";
      # mptopdf is a format link, but texlinks intentionally avoids it
      # so we add it back to binfiles to generate it from mkPkgBin
      binfiles = (orig.mptopdf.binfiles or []) ++ [ "mptopdf" ];
    };

    pedigree-perl = orig.pedigree-perl // {
      postFixup = ''
        sed -e '1{ /perl$/!q1 ; s|perl$|perl -I '"$run"'/scripts/pedigree-perl| } ' -i "$out"/bin/*
      '';
    };

    pdfcrop = orig.pdfcrop // {
      binaliases = {
        rpdfcrop = "pdfcrop";
      };
    };

    pdftex = orig.pdftex // {
      scriptsFolder = "simpdftex";
    };

    ptex = orig.ptex // {
      binaliases = {
        pdvitomp = bin.metapost + "/bin/pdvitomp";
        pmpost = bin.metapost + "/bin/pmpost";
        r-pmpost = bin.metapost + "/bin/r-pmpost";
      };
    };

    texdef = orig.texdef // {
      binaliases = {
        latexdef = "texdef";
      };
    };

    texlive-scripts = orig.texlive-scripts // {
      scriptsFolder = "texlive";
      # mktexlsr is distributed by texlive.infra which we exclude from tlpdb.nix
      # man should of course be ignored
      binfiles = (lib.remove "man" orig.texlive-scripts.binfiles) ++ [ "mktexlsr" ];
      binaliases = {
        mktexfmt = "fmtutil";
        texhash = "mktexlsr";
      };
      # fmtutil, updmap need modified perl @INC, including bin.core for TeXLive::TLUtils
      postFixup = ''
        sed -e '1{ /perl$/!q1 ; s|perl$|perl -I '"$run"'/scripts/texlive -I ${bin.core}/share/texmf-dist/scripts/texlive| } ' -i "$out"/bin/fmtutil "$out"/bin/updmap
      '';
    };

    texlive-scripts-extra = orig.texlive-scripts-extra // lib.optionalAttrs
    (lib.all (e: lib.elem e orig.texlive-scripts-extra.binfiles) [ "allec" "kpsepath" "kpsexpand" ])
    {
      scriptsFolder = "texlive-extra";
      binaliases = {
        allec = "allcm";
        kpsepath = "kpsetool";
        kpsexpand = "kpsetool";
      };
      # Patch texlinks.sh back to 2015 version;
      # otherwise some bin/ links break, e.g. xe(la)tex.
      postFixup = ''
        patch --verbose -R "$out"/bin/texlinks < '${./texlinks.diff}'
      '';
    };

    uptex = orig.uptex // {
      # upmendex is "TODO" in bin.nix
      # metapost binaries are in bin.metapost instead of bin.core
      binfiles = lib.remove "upmendex" orig.uptex.binfiles;
      binaliases = {
        r-upmpost = bin.metapost + "/bin/r-upmpost";
        updvitomp = bin.metapost + "/bin/updvitomp";
        upmpost = bin.metapost + "/bin/upmpost";
      };
    };

    # xindy is broken on some platforms unfortunately
    xindy = if (bin ? xindy)
      then orig.xindy // lib.optionalAttrs
      (lib.all (e: lib.elem e orig.xindy.binfiles) [ "xindy.mem" "xindy.run" ])
      {
        # we don't have xindy.run (we use the regular clisp somewhere in the nix store instead)
        # and xindy.mem is in lib/ (where it arguably belongs)
        binfiles = lib.subtractLists [ "xindy.mem" "xindy.run" ] orig.xindy.binfiles;
      }
      else removeAttrs orig.xindy [ "binfiles" ];

    xetex = orig.xetex // lib.optionalAttrs
    (lib.elem "teckit_compile" orig.xetex.binfiles)
    {
      scriptsFolder = "texlive-extra";
      # teckit_compile seems to be missing from bin.core{,-big}
      # TODO find it!
      binfiles = lib.remove "teckit_compile" orig.xetex.binfiles;
    };

    xdvi = orig.xdvi // { # it seems to need it to transform fonts
      deps = (orig.xdvi.deps or []) ++  [ "metafont" ];
    };

    # remove dependency-heavy packages from the basic collections
    collection-basic = orig.collection-basic // {
      deps = lib.filter (n: n != "metafont" && n != "xdvi") orig.collection-basic.deps;
    };
    # add them elsewhere so that collections cover all packages
    collection-metapost = orig.collection-metapost // {
      deps = orig.collection-metapost.deps ++ [ "metafont" ];
    };
    collection-plaingeneric = orig.collection-plaingeneric // {
      deps = orig.collection-plaingeneric.deps ++ [ "xdvi" ];
    };

    texdoc = orig.texdoc // {
      extraRevision = ".tlpdb${toString tlpdbVersion.revision}";
      extraVersion = "-tlpdb-${toString tlpdbVersion.revision}";

      # build Data.tlpdb.lua (part of the 'tlType == "run"' package)
      postUnpack = ''
        if [[ -f "$out"/scripts/texdoc/texdoc.tlu ]]; then
          unxz --stdout "${tlpdbxz}" > texlive.tlpdb

          # create dummy doc file to ensure that texdoc does not return an error
          mkdir -p support/texdoc
          touch support/texdoc/NEWS

          TEXMFCNF="${bin.core}"/share/texmf-dist/web2c TEXMF="$out" TEXDOCS=. TEXMFVAR=. \
            "${bin.luatex}"/bin/texlua "$out"/scripts/texdoc/texdoc.tlu \
            -c texlive_tlpdb=texlive.tlpdb -lM texdoc

          cp texdoc/cache-tlpdb.lua "$out"/scripts/texdoc/Data.tlpdb.lua
        fi
      '';
    };

    # tlshell is a GUI for tlmgr, which cannot be used in the Nix store
    tlshell = removeAttrs orig.tlshell [ "binfiles" "hasRunfiles" ];
  }; # overrides

  tl = lib.mapAttrs mkTLPkg overridden;

  # create a TeX package: an attribute set { pkgs = [ ... ]; ... } where pkgs is a list of derivations
  mkTLPkg = pname: attrs:
    let
      version = attrs.version or (toString attrs.revision);
      mkPkgV = tlType: let
        pkg = attrs // {
          sha512 = attrs.sha512.${if tlType == "tlpkg" then "run" else tlType};
          inherit pname tlType version;
        } // lib.optionalAttrs (tlType == "doc" && attrs.hasManpagesInDoc or false) {
          hasManpages = true;
        } // lib.optionalAttrs (tlType == "run" && attrs.hasManpagesInRun or false) {
          hasManpages = true;
        };
        in mkPkg pkg;
      # tarball of a collection/scheme itself only contains a tlobj file
      # likewise for most packages compiled in bin.core, bin.core-big
      # the fake derivations are used for filtering of hyphenation patterns and formats
      run = if (attrs.hasRunfiles or false) then mkPkgV "run"
          else ({
            inherit pname version;
            tlType = "run";
            hasHyphens = attrs.hasHyphens or false;
            tlDeps = map (n: tl.${n}) (attrs.deps or []);
          } // lib.optionalAttrs (attrs ? formats) { inherit (attrs) formats; });
    in {
      # TL pkg contains lists of packages: runtime files, docs, sources, binaries
      pkgs =
        [ run ]
        ++ lib.optional (attrs.sha512 ? doc) (mkPkgV "doc")
        ++ lib.optional (attrs.sha512 ? source) (mkPkgV "source")
        ++ lib.optional (attrs.hasTlpkg or false) (mkPkgV "tlpkg")
        ++ lib.optional (attrs ? binfiles) (mkPkgBin pname version run attrs);
    };

  # map: name -> fixed-output hash
  fixedHashes = lib.optionalAttrs useFixedHashes args.fixedHashes;

  # NOTE: the fixed naming scheme must match generated-fixed-hashes.nix
  # name for the URL
  mkURLName = { pname, tlType, ... }: pname + lib.optionalString (tlType != "run" && tlType != "tlpkg") ".${tlType}";
  # name + revision for the fixed output hashes
  mkFixedName = { tlType, revision, extraRevision ? "", ... }@attrs: mkURLName attrs + (lib.optionalString (tlType == "tlpkg") ".tlpkg") + ".r${toString revision}${extraRevision}";
  # name + version for the derivation
  mkTLName = { tlType, version, extraVersion ? "", ... }@attrs: mkURLName attrs + (lib.optionalString (tlType == "tlpkg") ".tlpkg") + "-${version}${extraVersion}";

  # build tlType == "bin" containers based on `binfiles` in TLPDB
  # see UPGRADING.md for how to keep the list of shebangs up to date
  # TODO: add extraBuildInputs (?) for adding PATH entries to texlive.combine wrappers
  mkPkgBin = pname: version: run:
  { binfiles, scriptsFolder ? pname, postFixup ? "", binaliases ? {}, ... }@args:
    let binNoAliases = assert (lib.all (e: lib.elem e binfiles) (lib.attrNames binaliases));
          lib.subtractLists (lib.attrNames binaliases) binfiles;
    in
    runCommand "texlive-${pname}.bin-${version}"
      ( {
          # metadata for texlive.combine
          passthru = {
            inherit pname version;
            tlType = "bin";
          };
          # shebang interpreters
          # TODO: package SNOBOL4
          buildInputs = [ bash perl python3 bin.luatex ruby tk ];
          run = run.outPath or "";
          inherit scriptsFolder;
        }
      )
      # look for scripts
      # the explicit list of extensions avoid non-scripts such as $binname.cmd, $binname.jar, $binname.pm
      # the order is relevant: $binname.sh is preferred to other $binname.*
      (''
        enable -f '${bash}/lib/bash/realpath' realpath
        mkdir -p "$out/bin"
        for binname in "${builtins.concatStringsSep "\" \"" binNoAliases}" ; do
          target="$out/bin/$binname"

          for bin in '${bin.core}'/bin/"$binname" ${lib.optionalString (bin ? ${pname}) ("'" + bin.${pname}.outPath + "'/bin/\"$binname\"")}; do
            if [[ -e "$bin" && -x "$bin" ]] ; then
              ln -s "$bin" "$target"
              continue 2
            fi
          done

          if [[ -n "$run" ]] ; then
            for script in "$run/scripts/$scriptsFolder/$binname"{,.sh,.lua,.pl,.py,.rb,.sno,.tcl,.texlua,.tlu}; do
              if [[ -e "$script" ]] ; then
                sed -e '1s|^eval '"'"'(exit \$?0)'"'"' && eval '"'"'exec perl -S .*$|#!${perl}/bin/perl|' \
                    -e 's|exec java |exec ${jdk}/bin/java |g' \
                    -e 's|exec perl |exec ${perl}/bin/perl |g' \
                    "$script" > "$target"
                chmod +x "$target"
                continue 2
              fi
            done
          fi
          echo "Error: could not find source for 'bin/$binname'" >&2
          exit 1
        done

        patchShebangs "$out/bin"
      '' +
      # generate aliases
      # we canonicalise the source to avoid symlink chains, and to check that it exists
      ''
        cd "$out"/bin
      '' +
      (lib.concatStrings (lib.mapAttrsToList (alias: source: ''
        ln -s "''$(realpath '${source}')" "$out"/bin/'${alias}'
      '') binaliases))
      + postFixup);

  # create a derivation that contains an unpacked upstream TL package
  mkPkg = { pname, tlType, revision, version, sha512, extraRevision ? "", postUnpack ? "", stripPrefix ? 1, ... }@args:
    let
      # the basename used by upstream (without ".tar.xz" suffix)
      urlName = mkURLName args;
      tlName = mkTLName args;
      fixedHash = fixedHashes.${mkFixedName args} or null; # be graceful about missing hashes

      urls = args.urls or (if args ? url then [ args.url ] else
        map (up: "${up}/archive/${urlName}.r${toString revision}.tar.xz") (args.urlPrefixes or urlPrefixes));

    in runCommand "texlive-${tlName}"
      ( {
          src = fetchurl { inherit urls sha512; };
          inherit stripPrefix tlType;
          # metadata for texlive.combine
          passthru = {
            inherit pname tlType revision version extraRevision;
          } // lib.optionalAttrs (tlType == "run" && args ? deps) {
            tlDeps = map (n: tl.${n}) args.deps;
          } // lib.optionalAttrs (tlType == "run") {
            hasHyphens = args.hasHyphens or false;
          } // lib.optionalAttrs (tlType == "tlpkg" && args ? postactionScript) {
            postactionScript = args.postactionScript;
          } // lib.optionalAttrs (args ? formats) {
            inherit (args) formats;
          } // lib.optionalAttrs (args ? hasManpages) { inherit (args) hasManpages; };
        } // lib.optionalAttrs (fixedHash != null) {
          outputHash = fixedHash;
          outputHashAlgo = "sha256";
          outputHashMode = "recursive";
        }
      )
      ( ''
          mkdir "$out"
          if [[ "$tlType"  == "tlpkg" ]]; then
            tar -xf "$src" \
              --strip-components=1 \
              -C "$out" --anchored --exclude=tlpkg/tlpobj --exclude=tlpkg/installer --exclude=tlpkg/gpg --keep-old-files \
              tlpkg
          else
            tar -xf "$src" \
              --strip-components="$stripPrefix" \
              -C "$out" --anchored --exclude=tlpkg --keep-old-files
          fi
        '' + postUnpack
      );

  };

  # like lib.makeOverridable, but for explicitly recursive sets
  makeOverridable = f: origArgs:
    f (lib.fix origArgs) // {
      overrideAttrs = newArgs: makeOverridable f (lib.extends newArgs origArgs);
    };
in
makeOverridable (args: args.tl) attrFun
